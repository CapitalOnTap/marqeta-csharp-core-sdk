using System.Linq;
using AutoFixture;
using AutoFixture.DataAnnotations;

namespace Marqeta.Core.Sdk.Tests.MarqetaContractsTests
{
    public abstract class BaseTests
    {
        /// <summary>
        /// Get the Fixture for use within tests
        /// </summary>
        /// <returns></returns>
        protected static Fixture GetFixture()
        {
            var fixture = new Fixture();

            // We remove data annotation consideration as the custom enums causes generation issues.
            fixture.Customize(new NoDataAnnotationsCustomization());

            // Replace `ThrowingRecursionBehavior` with `OmitOnRecursionBehavior`.
            // CF: https://github.com/AutoFixture/AutoFixture/wiki/Examples-of-using-behaviors
            fixture.Behaviors.OfType<ThrowingRecursionBehavior>().ToList().ForEach(b => fixture.Behaviors.Remove(b));
            fixture.Behaviors.Add(new OmitOnRecursionBehavior());

            // Custom fixtures for balances classes.
            // They cannot be autogenerated with AutoFixture.
            /*fixture.Customize<Cardholder_balance>(_ => _
                .With(x => x.Balances, new Cardholder_balances().AdditionalData.Add()
                {
                    { fixture.Create<string>(), fixture.Build<Cardholder_balance>().Without(p => p.Balances).Create() }
                }));
            fixture.Customize<Msa_aggregated_balances>(_ => _
                .With(x => x.Balances, new Dictionary<string, Msa_aggregated_balances>
                {
                    { fixture.Create<string>(), fixture.Build<Msa_aggregated_balances>().Without(x => x.Balances).Create() }
                }));
            fixture.Customize<Msa_balances>(_ => _
                .With(x => x.Balances, new Dictionary<string, Msa_balances>
                {
                    { fixture.Create<string>(), fixture.Build<Msa_balances>().Without(x => x.Balances).Create() }
                }));
            fixture.Customize<Offer_order_aggregated_balances>(_ => _
                .With(x => x.Balances, new Dictionary<string, Offer_order_aggregated_balances>
                {
                    { fixture.Create<string>(), fixture.Build<Offer_order_aggregated_balances>().Without(x => x.Balances).Create() }
                }));
            fixture.Customize<Offer_order_balances>(_ => _
                .With(x => x.Balances, new Dictionary<string, Offer_order_balances>
                {
                    { fixture.Create<string>(), fixture.Build<Offer_order_balances>().Without(x => x.Balances).Create() }
                }));
            fixture.Customize<Program_reserve_account_balance>(_ => _
                .With(x => x.Balances, new Dictionary<string, Program_reserve_account_balance>
                {
                    { fixture.Create<string>(), fixture.Build<Program_reserve_account_balance>().Without(x => x.Balances).Create() }
                }));

            // `Start_date` and `End_date` in card product models use a custom `DateFormatConverter`,
            // which converts the "yyyy-MM-dd" date format.
            fixture.Customize<Card_product_request>(_ => _
                .With(x => x.Start_date, fixture.Create<DateTimeOffset>().Date)
                .With(x => x.End_date, fixture.Create<DateTimeOffset>().Date));
            fixture.Customize<Card_product_response>(_ => _
                .With(x => x.Start_date, fixture.Create<DateTimeOffset>().Date)
                .With(x => x.End_date, fixture.Create<DateTimeOffset>().Date));
            fixture.Customize<Card_product_update_model>(_ => _
                .With(x => x.Start_date, fixture.Create<DateTimeOffset>().Date)
                .With(x => x.End_date, fixture.Create<DateTimeOffset>().Date));*/

            // We replace instances of `System.Object` with `Newtonsoft.Json.Linq.JObject`.
            // This is required as AutoFixture generates classes with empty `System.Object` types
            // that are deserialised as `Newtonsoft.Json.Linq.JObject`. `DeepEquals` will
            // incorrectly throw when comparing these type types.
            fixture.Register<object>(() => fixture.Create<Newtonsoft.Json.Linq.JObject>());

            return fixture;
        }
    }
}