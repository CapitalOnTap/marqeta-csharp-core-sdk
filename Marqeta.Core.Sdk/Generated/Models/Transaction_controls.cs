// <auto-generated/>
using Microsoft.Kiota.Abstractions.Serialization;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System;
namespace Marqeta.Core.Sdk.Models
{
    /// <summary>
    /// Controls transactional characteristics of card usage.
    /// </summary>
    public class Transaction_controls : IAdditionalDataHolder, IParsable
    {
        /// <summary>Set to `accept_us_only` to allow transactions only within the US.Set to `decline_ofac_countries` to allow international transactions except with countries that the Financial Action Task Force (FATF) and Office of Foreign Assets Control (OFAC) have identified as high risk.Users with the Admin role can create and update additional lists of accepted countries for transactions at the `/acceptedcountries` endpoint.See &lt;&lt;/core-api/accepted-countries, Accepted Countries&gt;&gt;.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? AcceptedCountriesToken { get; set; }
#nullable restore
#else
        public string AcceptedCountriesToken { get; set; }
#endif
        /// <summary>Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.</summary>
        public IDictionary<string, object> AdditionalData { get; set; }
        /// <summary>The address_verification property</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public Marqeta.Core.Sdk.Models.Avs_controls? AddressVerification { get; set; }
#nullable restore
#else
        public Marqeta.Core.Sdk.Models.Avs_controls AddressVerification { get; set; }
#endif
        /// <summary>Indicates whether to allow transactions where a Europay Mastercard and Visa (EMV) chip-enabled card was processed using the magstripe as fallback.</summary>
        public bool? AllowChipFallback { get; set; }
        /// <summary>*WARNING:* This field is deprecated and will be unsupported in a future release.Allows cardholders to define a personal identification number (PIN) as they complete their first PIN-debit transaction.</summary>
        public bool? AllowFirstPinSetViaFinancialTransaction { get; set; }
        /// <summary>If set to `true`, transactions can be authorized using GPA funds.*NOTE:* For most programs, this field should be set to `true`.</summary>
        public bool? AllowGpaAuth { get; set; }
        /// <summary>The &lt;&lt;/core-api/mcc-groups, MCC group&gt;&gt; `authorization_controls` object allows you to automatically increase authorization holds and to specify authorization expiration times based on merchant type.By default, these settings apply to all cards in your program.You can, however, exempt cards associated with a particular card product by setting this field to `false`.*NOTE:* Partial authorizations are disallowed if this field is set to `true`.</summary>
        public bool? AllowMccGroupAuthorizationControls { get; set; }
        /// <summary>Indicates whether card network loads are allowed.The associated card&apos;s state must be `ACTIVE` or the load will be rejected.</summary>
        public bool? AllowNetworkLoad { get; set; }
        /// <summary>Indicates whether card network loads are allowed.Sets the associated card&apos;s state to `ACTIVE` if its current state is `INACTIVE`.</summary>
        public bool? AllowNetworkLoadCardActivation { get; set; }
        /// <summary>Indicates whether quasi-cash transactions are allowed.In a quasi-cash transaction, the cardholder purchases an item that can be directly converted to cash, such as traveler&apos;s checks, money orders, casino chips, or lottery tickets.</summary>
        public bool? AllowQuasiCash { get; set; }
        /// <summary>If set to `true`, cards of this card product type require an Integrated Circuit Card.</summary>
        public bool? AlwaysRequireIcc { get; set; }
        /// <summary>If set to `true`, cards of this card product type require a personal identification number (PIN).</summary>
        public bool? AlwaysRequirePin { get; set; }
        /// <summary>The enable_credit_service property</summary>
        public bool? EnableCreditService { get; set; }
        /// <summary>Set to `true` to enable partial authorizations.When this setting is `false` and the requested authorization amount exceeds available funds, the transaction is declined.When this setting is `true` and the requested authorization amount exceeds available funds, the transaction is authorized for the amount of available funds.</summary>
        public bool? EnablePartialAuthApproval { get; set; }
        /// <summary>Allows transactions to be approved even if the card&apos;s `state = SUSPENDED`.When this field is set to `true`, the card behaves as if its `state = ACTIVE`.</summary>
        public bool? IgnoreCardSuspendedState { get; set; }
        /// <summary>Specifies the language for 3D Secure and digital wallet token notifications sent to cardholders under this card program.You can send notifications to your cardholders in the following languages:* *ces* – Czech* *deu* – German* *eng* – English* *fra* – French* *grc* – Greek* *ita* – Italian* *nld* – Dutch* *pol* – Polish* *prt* – Portuguese* *rou* – Romanian* *spa* – Spanish* *swe* – SwedishBy default, notifications are sent in English.To specify the language for OTP notifications at the user level, see &lt;&lt;/core-api/users, Users&gt;&gt;.Languages set at the user level take precedence over the language set at the card product level.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? NotificationLanguage { get; set; }
#nullable restore
#else
        public string NotificationLanguage { get; set; }
#endif
        /// <summary>The token of the merchant group that you want to exempt from quasi-cash transaction authorization control, allowing your cardholders to conduct quasi-cash transactions.In a quasi-cash transaction, the cardholder purchases an item that can be directly converted to cash, such as traveler&apos;s checks, money orders, casino chips, or lottery tickets.You can specify a merchant group token in addition to whatever merchant identifiers you listed in the `quasi_cash_exempt_mids` field, if any.For more information, see &lt;&lt;/core-api/merchant-groups, Merchant Groups&gt;&gt;.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? QuasiCashExemptMerchantGroupToken { get; set; }
#nullable restore
#else
        public string QuasiCashExemptMerchantGroupToken { get; set; }
#endif
        /// <summary>Comma-separated list of merchant identifiers that you want to exempt from quasi-cash transaction authorization control, allowing your cardholders to conduct quasi-cash transactions.In a quasi-cash transaction, the cardholder purchases an item that can be directly converted to cash, such as traveler&apos;s checks, money orders, casino chips, or lottery tickets.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? QuasiCashExemptMids { get; set; }
#nullable restore
#else
        public string QuasiCashExemptMids { get; set; }
#endif
        /// <summary>A value of `true` indicates that if `card_presence_required` is `true`, the card&apos;s security code is required.</summary>
        public bool? RequireCardNotPresentCardSecurityCode { get; set; }
        /// <summary>Contains information about Strong Customer Authentication (SCA) behavior for contactless point-of-sale (POS) and low-value payment (LVP) e-commerce transactions.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public Marqeta.Core.Sdk.Models.Strong_customer_authentication_limits? StrongCustomerAuthenticationLimits { get; set; }
#nullable restore
#else
        public Marqeta.Core.Sdk.Models.Strong_customer_authentication_limits StrongCustomerAuthenticationLimits { get; set; }
#endif
        /// <summary>
        /// Instantiates a new <see cref="Marqeta.Core.Sdk.Models.Transaction_controls"/> and sets the default values.
        /// </summary>
        public Transaction_controls()
        {
            AdditionalData = new Dictionary<string, object>();
        }
        /// <summary>
        /// Creates a new instance of the appropriate class based on discriminator value
        /// </summary>
        /// <returns>A <see cref="Marqeta.Core.Sdk.Models.Transaction_controls"/></returns>
        /// <param name="parseNode">The parse node to use to read the discriminator value and create the object</param>
        public static Marqeta.Core.Sdk.Models.Transaction_controls CreateFromDiscriminatorValue(IParseNode parseNode)
        {
            _ = parseNode ?? throw new ArgumentNullException(nameof(parseNode));
            return new Marqeta.Core.Sdk.Models.Transaction_controls();
        }
        /// <summary>
        /// The deserialization information for the current model
        /// </summary>
        /// <returns>A IDictionary&lt;string, Action&lt;IParseNode&gt;&gt;</returns>
        public virtual IDictionary<string, Action<IParseNode>> GetFieldDeserializers()
        {
            return new Dictionary<string, Action<IParseNode>>
            {
                { "accepted_countries_token", n => { AcceptedCountriesToken = n.GetStringValue(); } },
                { "address_verification", n => { AddressVerification = n.GetObjectValue<Marqeta.Core.Sdk.Models.Avs_controls>(Marqeta.Core.Sdk.Models.Avs_controls.CreateFromDiscriminatorValue); } },
                { "allow_chip_fallback", n => { AllowChipFallback = n.GetBoolValue(); } },
                { "allow_first_pin_set_via_financial_transaction", n => { AllowFirstPinSetViaFinancialTransaction = n.GetBoolValue(); } },
                { "allow_gpa_auth", n => { AllowGpaAuth = n.GetBoolValue(); } },
                { "allow_mcc_group_authorization_controls", n => { AllowMccGroupAuthorizationControls = n.GetBoolValue(); } },
                { "allow_network_load", n => { AllowNetworkLoad = n.GetBoolValue(); } },
                { "allow_network_load_card_activation", n => { AllowNetworkLoadCardActivation = n.GetBoolValue(); } },
                { "allow_quasi_cash", n => { AllowQuasiCash = n.GetBoolValue(); } },
                { "always_require_icc", n => { AlwaysRequireIcc = n.GetBoolValue(); } },
                { "always_require_pin", n => { AlwaysRequirePin = n.GetBoolValue(); } },
                { "enable_credit_service", n => { EnableCreditService = n.GetBoolValue(); } },
                { "enable_partial_auth_approval", n => { EnablePartialAuthApproval = n.GetBoolValue(); } },
                { "ignore_card_suspended_state", n => { IgnoreCardSuspendedState = n.GetBoolValue(); } },
                { "notification_language", n => { NotificationLanguage = n.GetStringValue(); } },
                { "quasi_cash_exempt_merchant_group_token", n => { QuasiCashExemptMerchantGroupToken = n.GetStringValue(); } },
                { "quasi_cash_exempt_mids", n => { QuasiCashExemptMids = n.GetStringValue(); } },
                { "require_card_not_present_card_security_code", n => { RequireCardNotPresentCardSecurityCode = n.GetBoolValue(); } },
                { "strong_customer_authentication_limits", n => { StrongCustomerAuthenticationLimits = n.GetObjectValue<Marqeta.Core.Sdk.Models.Strong_customer_authentication_limits>(Marqeta.Core.Sdk.Models.Strong_customer_authentication_limits.CreateFromDiscriminatorValue); } },
            };
        }
        /// <summary>
        /// Serializes information the current object
        /// </summary>
        /// <param name="writer">Serialization writer to use to serialize this model</param>
        public virtual void Serialize(ISerializationWriter writer)
        {
            _ = writer ?? throw new ArgumentNullException(nameof(writer));
            writer.WriteStringValue("accepted_countries_token", AcceptedCountriesToken);
            writer.WriteObjectValue<Marqeta.Core.Sdk.Models.Avs_controls>("address_verification", AddressVerification);
            writer.WriteBoolValue("allow_chip_fallback", AllowChipFallback);
            writer.WriteBoolValue("allow_first_pin_set_via_financial_transaction", AllowFirstPinSetViaFinancialTransaction);
            writer.WriteBoolValue("allow_gpa_auth", AllowGpaAuth);
            writer.WriteBoolValue("allow_mcc_group_authorization_controls", AllowMccGroupAuthorizationControls);
            writer.WriteBoolValue("allow_network_load", AllowNetworkLoad);
            writer.WriteBoolValue("allow_network_load_card_activation", AllowNetworkLoadCardActivation);
            writer.WriteBoolValue("allow_quasi_cash", AllowQuasiCash);
            writer.WriteBoolValue("always_require_icc", AlwaysRequireIcc);
            writer.WriteBoolValue("always_require_pin", AlwaysRequirePin);
            writer.WriteBoolValue("enable_credit_service", EnableCreditService);
            writer.WriteBoolValue("enable_partial_auth_approval", EnablePartialAuthApproval);
            writer.WriteBoolValue("ignore_card_suspended_state", IgnoreCardSuspendedState);
            writer.WriteStringValue("notification_language", NotificationLanguage);
            writer.WriteStringValue("quasi_cash_exempt_merchant_group_token", QuasiCashExemptMerchantGroupToken);
            writer.WriteStringValue("quasi_cash_exempt_mids", QuasiCashExemptMids);
            writer.WriteBoolValue("require_card_not_present_card_security_code", RequireCardNotPresentCardSecurityCode);
            writer.WriteObjectValue<Marqeta.Core.Sdk.Models.Strong_customer_authentication_limits>("strong_customer_authentication_limits", StrongCustomerAuthenticationLimits);
            writer.WriteAdditionalData(AdditionalData);
        }
    }
}
